<?xml version="1.0" encoding="windows-1251"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>Стандарт Кодинга (Форматирования Кода) для YF.Engine</title>
	<meta content="text/html; charset=windows-1251" http-equiv="Content-Type" />
</head>
<body alink="#cccccc" bgcolor="#ffffff" link="#0000ff" text="#000000" vlink="#0000ff">
<font face="verdana,arial,tahoma" size="-1"><a name="top" id="top"></a>


<h2>Стандарт Кодинга (Форматирования Кода) для YF.Engine</h2>


Комментарии или дополнения?  
Пишите <a href="mailto:yfix.dev@gmail.com">yfix.dev@gmail.com</a><br />
<br />

<a href="#editor">Настройки редактора</a><br />
<a href="#naming">Согляшения об именовании элементов</a><br />
<a href="#layout">Представление кода</a><br />
<a href="#general">Основные понятия</a><br />
<br />
<br />
<a name="editor" id="editor"></a><a href="#top">Наверх</a> 


<h3>Настройки редактора</h3>


<p>Для форматирования кода необходимо использовать TAB, а не пробелы.
	Используйте в редакторе то количество пробелов, к которому привыкли, для <b>отображения</b> TAB-ов, 
	но удостоверьтесь, что когда Вы <b>сохраняете</b> файл, он сохраняется с TAB-ами, а не пробелами. 
	Таким методом мы можем добиться просмотра кода более привычным путем, 
	без изменения структуры существующих файлов. </p>
<p><b>Переводы строки/Возвраты каретки (CR/LF):</b> 
	Проверьте, что Ваш редактор сохраняет файлы в формате WIN32.
	То есть каждая линия заканчивается CR/LF парой символов, а не просто символом новой строки
	как в UNIX. </p>
<br />
<br />
<a name="naming" id="naming"></a><a href="#top">Наверх</a> 


<h3>Соглашения об именовании элементов</h3>


<p>Мы не будем использовать никакую из форм венгерской нотации или подобных ей при именовании
	элементов кода. </p>

<p><b>Имена переменных:</b> 

	Имена переменных должны быть все в нижнем регистре, со словами разделенными
	символом подчеркивания. <br />
	<br />
	&nbsp;&nbsp;&nbsp;&nbsp;Например: <code><font 
size="+1">$current_user</font></code> правильно, но <code><font 
size="+1">$currentuser</font></code> и <code><font 
size="+1">$currentUser</font></code> не правильно. <br />
	<br />
	Имена должны быть понятные, но в то же время лаконичные.
	Мы не хотим огромных предложений в качестве имен переменных, но в то же время
	добавление нескольких символов для понятности всегда лучше чем
	потом процесс отгадывания для чего же на самом деле введена конкретная переменная. </p>

<p><b>Индексы в циклах:</b> 

	<i>Единственная</i> ситуация, где применима переменная, состоящая
	из одного символа - это когда она используется в качестве индекса в каком-либо цикле.
	В этом случае индекс для внешнего массива должен быть обязательно $i.
	Если есть вложенный цикл внутри текущего, то его индекс должен быть $j, 
	для следующего - $k, и т д.
	Если цикл индексируется при помощи какой-либо предварительно определенной переменной -
	то это правило не действует.<br />
	<br />

	&nbsp;&nbsp;&nbsp;&nbsp;Например: </p>
<pre><font size="+1">
		for ($i = 0; $i &lt; $outer_size; $i++) {
		   for ($j = 0; $j &lt; $inner_size; $j++) {
		      foo($i, $j);
		   }
		} </font></pre>
<p></p>

<p><b>Имена функций:</b> 

	Функции также должны именоваться понятно и исчерпывающе.
	Мы тут программируем не на С, поэтому не хотим, чтобы наши функции назывались вроде
	"stristr()". Еще раз, все имена в нижнем регистре, слова разделяются знаками подчеркивания.
	Желательно, чтобы имя функции содержало в себе глагол.
	Вот хорошие примеры функций:
<code><font size="+1">print_login_status()</font></code>, 
<code><font size="+1">get_user_data()</font></code>, и т д.. </p>

<p><b>Аргументы функций:</b> 

	Аргументы подчиняются тем же правилам, что и имена переменных.
	Неприменимы подобные описания функций:
	<code><font size="+1">do_stuff($a, $b, $c)</font></code>. 
	В большинстве случаев желательно сразу получать представление о том, как использовать
	у или иную функцию глядя на ее определение.
</p>

<p><b>Итак, подведем итоги:</b> 

	Основная идея здесь - это не нарушить читабельность кода в ущерб той или иной крайности.
	Всегда нужно придерживаться здравого смысла при именовании элементов кода.
	Например; <code><font size="+1">print_login_status_for_a_given_user()</font></code> 
	слишком длинное название, эту функцию лучше назвать 
	<code><font size="+1">print_user_login_status()</font></code> , или просто 
	<code><font size="+1">print_login_status()</font></code>. </p>
<br />
<br />
<a name="layout" id="layout"></a><a href="#top">Наверх</a> 

<h3>Представление кода</h3>

<p><b>Вот стандартная шапка для новых файлов:</b> 
	Это шаблон шапки, которая должна быть включена во ВСЕ файлы YF.Engine: </p>
<pre><font size="+1">
//#### file_name: forum_admin.class.php, ver:1.0.1, last_modified: 12.11.05 ####//

//-----------------------------------------------------------------------------
// Your code here
function some_func () {
}
//-----------------------------------------------------------------------------
</font></pre>
<p></p>

<p><b>Всегда добавляйте кавычки:</b> 

	Лень в случае не добавления пары фигурных скобок может в дальнейшем привести как к 
	непредсказуемым ошибкам, так и просто сильно затрудняет 
	читабельность кода,	особенно с ростом размера файла.

	Даже если тело какой-либо конструкции состоит всего-лишь из одной линии,
	<i>НЕ НАДО</i> опускать фигурные скобки.
	<br />
	<br />
	&nbsp;&nbsp;&nbsp;Примеры:</p>
<pre><font size="+1">
		/* Это все неправильно. */
		if (condition)	do_stuff();
		if (condition)
			do_stuff();
		while (condition) 
			do_stuff();
		for ($i = 0; $i &lt; size; $i++)
			do_stuff($i);
		
		/* Так правильно. */
		if (condition) {
			do_stuff();
		}
		while (condition) {
			do_stuff();
		}
		for ($i = 0; $i &lt; size; $i++) {
			do_stuff();
		}
	</font></pre>
<p></p>

<p><b>Где располагать фигурные скобки:</b> 

    Мы используем стиль принятый сообществом PEAR lzk форматирования фигурных скобок.
	Это подразумевает, что открывающая фигурная скобка находится на одной линии с соответствующим 
	оператором и должна быть отделена от него одним пробелом.
	Закрывающая скобка должна быть на той же вертикальной колонке что и оператор.
	<br />
	<br />
	&nbsp;&nbsp;&nbsp;Примеры:</p>
<pre><font size="+1">
		if (condition) {
			while (condition2) {
				...
			}
		} else {
			...
		}

		for ($i = 0; $i &lt; $size; $i++) {
			...
		}
		
		while (condition) {
			...
		}
		
		function do_stuff() {
			...
		}
	</font></pre>
<p></p>

<p><b>Используйте пробелы между выражениями:</b> 

	Еще одно простое и понятное соглашение, которое помогает сохранять читабельность и
	стандартизованность кода.
	Что бы вы ни писали, определение, выражение и пр.
	Всегда оставляйте <i>один</i> пробел между выражениями. В основном, пишите код так, как Вы 
	пишете обычное текстовое предложение (на Русском, Английском и т д).
	Ставьте пробелы между именами переменных и операторами.
	Не ставьте пробелов сразу после открывающих скобок или перед закрывающей скобкой.
	Не ставьте пробелов сразу перед запятой или точкой.
	Лучше всего это понять из следующих фрагментов кода. <br />
	<br />
	&nbsp;&nbsp;&nbsp;Примеры:</p>
<pre><font size="+1">
		/* Каждая пара начинается неправильным форматированием и заканчивается правильным. */
		
		$i=0;
		$i = 0;
		
		if($i&lt;7) ...
		if ($i &lt; 7) ...
		
		if ( ($i &lt; 7)&amp;&amp;($j &gt; 8) ) ...
		if (($i &lt; 7) &amp;&amp; ($j &gt; 8)) ...
		
		do_stuff( $i, "foo", $b );
		do_stuff($i, "foo", $b);
		
		for($i=0; $i&lt;$size; $i++) ...
		for($i = 0; $i &lt; $size; $i++) ... 
		
		$i=($j &lt; $size)?0:1;
		$i = ($j &lt; $size) ? 0 : 1;
	</font></pre>
<p></p>

<p><b>Порядок исполнения операторов:</b> 

	Знаете ли вы точный порядок выполнения операторов в РНР ?
	Даже если вы сильно потрудились и выучили его, это не сильно поможет вам в скорости
	понимания и написания кода. Кроме того, помните, что Ваш код будут просматривать и другие люди,
	поэтому не стоит показывать насколько вы выучили одну концепцию. 
	Лучше сделайте код немного более избыточным, зато намного лучше читаемым, добавив
	дополнительные скобки вокруг условных выражений.
	<br />
	<br />
	&nbsp;&nbsp;&nbsp;Примеры:</p>
<pre><font size="+1">
		/* Что в результате? Кто знает.... */
		$bool = ($i &lt; 7 &amp;&amp; $j &gt; 8 || $k == 4);
		
		/* Теперь вы можете быть уверены в том, что тут происходит. */
		$bool = (($i &lt; 7) &amp;&amp; (($j &lt; 8) || ($k == 4)))
		</font></pre>
<p></p>

<p><b>Форматирование SQL кода:</b> 

	Так как мы все используем разные редакторы кода и их настройки,
	старайтесь не делать какие-нибудь сложные выравнивания в SQL коде.
	Желательно разбивать выражение на отдельные линии.
	SQL выражения, имена функций и тп должны быть в верхнем регистре.
	Если Вы точно уверены, что кроме MySQL другие СУБД использовать не будете - 
	желательно имена полей, таблиц обертывать в обратные одинарные кавычки для того, чтобы
	избежать пересечений с зарезервированными словами в именах полей.
	Вот пример как в идеале должен выглядеть SQL код. 
	<br />
	<br />
	&nbsp;&nbsp;&nbsp;Примеры:</p>
<pre><font size="+1">
		SELECT field1 AS something, field2, field3
		FROM table a, table b
		WHERE (this = that) AND (this2 = that2)
		</font></pre>
<p></p>

<p><b>SQL INSERT выражения:</b> 

	SQL INSERT выражения могут быть написаны двумя основными способами. 
	Если вы передаете список значений полей для вставки - это говорит о том, что вы знаете
	порядок расположений полей в таблице СУБД и не перечисляете их.
	Мы хотим использовать второй способ - более избыточный, зато работающий наверняка,
	даже в случае изменения порядка полей в таблице.<br />
	<br />
	&nbsp;&nbsp;&nbsp;Примеры:</p>
<pre><font size="+1">
		# Это не то, что нам нужно
		INSERT INTO mytable
		VALUES ('something', 1, 'else')
		
		# Так правильно.
		INSERT INTO mytable (column1, column2, column3)
		VALUES ('something', 1, 'else')
		</font></pre>
<p></p>
<br />
<br />
<a name="general" id="general"></a><a href="#top">Наверх</a> 


<h3>Основные понятия</h3>


<p><b>Строки и окружающие кавычки:</b> 

	Существует два основных способа для окружения строк кавычками в РНР - 
	с одинарными и с двойными кавычками. Основная разница состоит в том, что парсер производит
	поиск и замену переменных на их значения в строках, окруженных двойными кавычками, но не 
	в строках, заключенных в одинарные кавычки. Поэтому настоятельно рекомендуется <i>Всегда</i>
	использовать одинарные кавычки для простых строк точно не содержащих переменных.
	Конечно кроме случаев, когда Вам действительно необходимо обрабатывать переменные внутри строки.
	Кроме того, это связано еще и с дополнительной нагрузкой на парсер, который пытается найти 
	переменные в строке, заключенной в двойные кавычки (разница особенно заметна на больших строках).
	Но, при этом, если Вы используете строковую переменную в качестве аргумента функции, то
	не нужно ее заключать в кавычки. Это тоже лишь добавление ненужной работы для парсера.
	Кроме того, будьте внимательны, так как почти все escape-выражения не работают внутри 
	одинарных кавычек.
	<br />
	<br />
	&nbsp;&nbsp;&nbsp;Примеры:</p>
<pre><font size="+1">
		/* неправильно */
		$str = "Это действительно длинная строка без переменных внутри нее, которые будет искать парсер.";
		do_stuff("$str");
		
		/* правильно */
		$str = 'Это действительно длинная строка без переменных внутри нее, которые будет искать парсер.';
		do_stuff($str);
		</font></pre>
<p></p>

<p><b>Ключи ассоциативных массивов:</b> 

	В PHP, возможно использование символьных ключей для ассоциативных массивов без
	заключения этих символов в кавычки.
	Мы против такого написания кода, так как с ростом размеров проекта, добавления новых 
	констант, возможно получение непредсказуемых результатов и трудно выявляемых ошибок,
	связанных с тем, что эти самые наборы символов парсер будет пытаться заменить на значение 
	соответствующих констант. Кроме того, код становится менее удобочитаем без использования
	кавычек.
	Обратите внимание, что это все касается использования наборов символов, но не переменных.
	<br />
	<br />
	&nbsp;&nbsp;&nbsp;Примеры:</p>
<pre><font size="+1">
		/* неправильно */
		$foo = $assoc_array[blah];
		
		/* правильно */
		$foo = $assoc_array['blah'];
		</font></pre>
<p></p>

<p><b>Комментарии:</b> 

	Каждая функция должна быть снабжена комментарием, в котором указывается все, что
	программист должен знать про эту функцию.
	Желательно перечисление значения каждого параметра, ожидаемое значение и результат
	работы функции.<br />
	<br />
	Кроме того, необходимы комментарии для любого нестандартного кода, использующего различные
	трюки, хитрые алгоритмы или все что угодно, что не будет понятно сходу тому, что просматривает
	этот код. 
	Результатом правильного комментирования кода будет являться ускорение понимания что же 
	все-таки в нем происходит.
	</p>

<p><b>Короткие операторы:</b> 

	Единственные короткие операторы, которые могут вызвать проблемы при чтении кода - это
	операторы инкремента ($i++) и декремента ($j--)
	Они не должны использоваться как часть выражения. Хотя при этом их можно использоваться на 
	отдельной линии кода. Использование их в выражениях - это гарантированное добавление головной 
	боли при отладке и поиске ошибок. <br />
	<br />
	&nbsp;&nbsp;&nbsp;Примеры:</p>
<pre><font size="+1">
		/* неправильно */
		$array[++$i] = $j;
		$array[$i++] = $k;
		
		
		/* правильно */
		$i++;
		$array[$i] = $j;
		
		$array[$i] = $k;
		$i++;
		</font></pre>
<p></p>

<p><b>Встроенные условия (тернарный оператор):</b> 

	Встроенные условия должны использоваться только для простых вещей.
	Желательно, их использовать в присвоениях, но не в вызовах функций или в чем-то 
	более сложном. Кроме того, они могут плохо повлиять на восприятие кода при частом и 
	сложном использовании.
	Поэтому не экономьте секунды на наборе этих простых условий, и пользуйтесь ими лишь в простых
	случаях.
	<br />
	<br />
	&nbsp;&nbsp;&nbsp;Примеры:</p>
<pre><font size="+1">
		/* Плохое место для их использования */
		(($i &lt; $size) &amp;&amp; ($j &gt; $size)) ? do_stuff($foo) : do_stuff($bar);
		
		
		/* Хорошее место для их использования */
		$min = ($i &lt; $j) ? $i : $j;
		</font></pre>
<p></p>

<p><b>Не используйте неинициализированные переменные.</b> 

	Не используйте неинициализированные переменные. 
	Для YF.Engine, мы намереваемся использовать более высокий уровень сообщения об
	ошибках во время выполнения программы. Это будет подразумевать что использование 
	неинициализированной переменной будет сообщаться как ошибка. Это используется
	наиболее часто при проверке, какие переменные переданы из HTML формы. Этих ошибок
	можно избежать, используя встроенную функцию isset(), чтобы проверить, 
	установлена ли переменная. <br />
	<br />
	&nbsp;&nbsp;&nbsp;Примеры:</p>
<pre><font size="+1">
		/* Старый способ */
		if ($forum) ...
		
		
		/* Новый способ */
		if (isset($forum)) ...
		</font></pre>
<p></p>
<br />
<br />
<a href="#top">Наверх</a> </font> 
</body>
</html>
